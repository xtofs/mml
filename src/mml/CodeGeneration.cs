namespace mml;

public static class MetaModelExtensions
{
    const string HEADER = """
        // <auto-generated>
        //     This code was generated by a tool.
        //
        //     Changes to this file may cause incorrect behavior and
        //     will be lost if the code is regenerated.
        // </auto-generated>
        using model;

        """;
    public static void GenerateCode(this MetaModel model, TextWriter writer)
    {
        writer.WriteLine(HEADER);

        foreach (var classifier in model.Classifiers)
        {
            switch (classifier)
            {
                case Class @class:
                    GenerateClass(@class, writer);
                    break;
                case Trait @trait:
                    GenerateInterface(@trait, writer);
                    break;
            }
        }
    }

    private static bool FilterByPrimitiveType(Field field, [MaybeNullWhen(false)] out (string Name, Builtin Type) res)
    {
        if (field.Type is Builtin bi) { res = (field.Name, bi); return true; }
        res = default!;
        return false;
    }

    private static void GenerateClass(Class classifier, TextWriter writer)
    {
        writer.WriteLine($"public class {classifier.Name}: Node{classifier.Extends.Join(", ", ", ")}");
        writer.WriteLine("{");

        // constructor
        var fieldsOfPrimitiveType = classifier.Fields.FilterSelect<Field, (string Name, Builtin Type)>(FilterByPrimitiveType);
        var fieldsOfNonPrimitiveType = classifier.Fields.Where(f => f.Type is not Builtin);

        var args = string.Join(", ", from arg in fieldsOfPrimitiveType select $"{arg.Item2.CSharpName} {arg.Item1}");
        var nameField = fieldsOfPrimitiveType.Select(f => f.Name).FirstOrDefault() ?? "\"\"";

        writer.WriteLine($"    public  {classifier.Name} ({args}) : base({nameField})");
        writer.WriteLine($"    {{");
        foreach (var field in fieldsOfNonPrimitiveType)
        {
            var (name, type, _) = field;
            switch (type)
            {
                case Builtin bi:
                    writer.WriteLine($"= default!; // = {name}");
                    break;
                case Contained co:
                    writer.WriteLine($"        this.{field.Name} = new ContainedSingleton<{co.Name}>(this);");
                    break;
                case Reference re:
                    writer.WriteLine($"        this._{field.Name} = new ReferencedSingleton<{re.Name}>(this);");
                    break;
                case Dictionary di:
                    writer.WriteLine($"        this.{field.Name} = new ContainedCollection<{di.Type}>(this, (x) => x.{string.Join(".", di.Path)});");
                    break;
                default:
                    throw new InvalidOperationException($"unknown enum value {type}");
            };
        }
        writer.WriteLine("    }");

        // properties except the name property inherited from Node
        foreach (var field in classifier.Fields)
        {
            writer.WriteLine();

            var (name, type, _) = field;

            if (name == "Name" && type == Builtin.String)
            {
                continue;
            }
            var attr = name == "Name" ? "new " : "";

            switch (type)
            {
                case Builtin bi:
                    writer.WriteLine($"    public {attr}{bi.CSharpName} {name} {{ get; }}");
                    break;
                case Contained co:
                    writer.WriteLine($"    public {attr} ContainedSingleton<{co.Name}> {name} {{ get; }}");
                    break;
                case Reference re:
                    writer.WriteLine($"    private ReferencedSingleton<{re.Name}> _{name} {{ get; }}");
                    writer.WriteLine($"    public {attr}{re.Name} {name} {{ get => _{name}.Get<{re.Name}>(); set => _{name}.Set(value); }}");
                    break;
                case Dictionary di:
                    writer.WriteLine($"    public {attr}ContainedCollection<{di.Type}> {name} {{ get; }}");
                    break;
                default:
                    throw new InvalidOperationException($"unknown enum value {type}");
            }
            // writer.WriteLine($"    public {FieldAsProperty(field.Name, field.Type)} {{ get; protected init; }}");
        }

        writer.WriteLine("}");
        writer.WriteLine();
    }



    private static void GenerateInterface(Trait trait, TextWriter writer)
    {
        writer.WriteLine($"public interface {trait.Name}: INode{trait.Extends.Join(", ", ", ")}");
        writer.WriteLine("{");
        var fieldsOfPrimitiveType = trait.Fields.FilterSelect<Field, (string Name, Builtin Type)>(FilterByPrimitiveType);
        var fieldsOfNonPrimitiveType = trait.Fields.Where(f => f.Type is not Builtin);

        // properties except the name property inherited from Node
        foreach (var field in trait.Fields)
        {
            if (field.Name == "Name" && field.Type == Builtin.String)
            {
                continue;
            }
            writer.WriteLine();
            // writer.WriteLine($"    public {FieldAsProperty(field.Name, field.Type)} {{ get; protected init; }}");
        }

        writer.WriteLine("}");
        writer.WriteLine();
    }

    // static string FieldAsProperty(string name, FieldType type)
    // {
    //     return type switch
    //     {
    //         Builtin bi =>
    //             $"{bi.CSharpName} {name}",
    //         Contained co =>
    //             $"ContainedSingleton<{co.Name}> {name}",
    //         Reference re =>
    //             $"ReferencedSingleton<{re.Name}> {name}",
    //         Dictionary di =>
    //             $"ContainedCollection<{di.Type}> {name}",
    //         _ =>
    //             throw new InvalidOperationException($"unknown enum value {type}")
    //     };
    // }

    // static string PropertyInit(string name, FieldType type)
    // {
    //     return type switch
    //     {
    //         Builtin bi =>
    //             $"= default!; // = {name}",
    //         Contained co =>
    //             $"= new ContainedSingleton<{co.Name}>(this);",
    //         Reference re =>
    //             $"= new ReferencedSingleton<{re.Name}>(this);",
    //         Dictionary di =>
    //             $"= new ContainedCollection<{di.Type}>(this, (x) => x.{string.Join(".", di.Path)});",
    //         _ =>
    //             throw new InvalidOperationException($"unknown enum value {type}")
    //     };
    // }
}

